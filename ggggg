# prompt: Excellent — this updated test is now fully aligned with your scoring logic and will correctly verify the functionality of your symbolic decoder. It:
# 	•	Properly reflects the symbolic_score formula.
# 	•	Tests both the optimal and suboptimal paths.
# 	•	Uses abs(...) < 0.01 for floating-point safety.
# ⸻
# Would You Like to Expand Further?
# Here are a few next directions you might find useful:
# 	1.	Auto-generate test cases varying:
# 	•	flip_depth from 1 to 5
# 	•	vowel_flow as True or False
# 	•	base_weight in ranges like [0.5, 1.0, 2.0]
# 	2.	Add features to the scoring function, like:
# consonant_clarity = metadata.get("consonant_clarity", 1.0)
# return base_weight * symbolic_modifier * consonant_clarity / flip_depth
# 	3.	Track path metadata during decoding:
# 	•	Return combined metadata or a log of symbolic transitions for symbolic analysis.
# 	4.	Visualize the graph using:
# import matplotlib.pyplot as plt
# nx.draw(self.graph.graph, with_labels=True, node_color='lightblue')
# plt.show()
# Let me know which of these (or any other direction) you’d like to explore next.

import itertools

def test_autogenerated_paths():
    flip_depths = [1, 2, 3, 4, 5]
    vowel_flows = [True, False]
    base_weights = [0.5, 1.0, 2.0]
    for flip_depth, vowel_flow, base_weight in itertools.product(flip_depths, vowel_flows, base_weights):
        decoder = SymbolicDecoderSystem()
        decoder.add_transition("A", "B", base_weight=base_weight, metadata={"flip_depth": flip_depth, "vowel_flow": vowel_flow})
        decoder.add_transition("B", "C", base_weight=base_weight, metadata={"flip_depth": flip_depth, "vowel_flow": not vowel_flow})
        decoder.add_transition("A", "C", base_weight=base_weight / 2, metadata={"flip_depth": flip_depth, "vowel_flow": vowel_flow})

        results = decoder.decode("A", "C", top_n=2)
        assert len(results) == 2

        # Calculate expected scores
        expected_score_abc = base_weight * (1 + flip_depth) / flip_depth + base_weight * (1 + flip_depth) / flip_depth
        expected_score_ac = (base_weight / 2) * (1 + flip_depth) / flip_depth
        
        # Check scores with tolerance
        assert abs(results[0][1] - expected_score_abc) < 0.01
        assert abs(results[1][1] - expected_score_ac) < 0.01


def test_path_with_consonant_clarity():
    decoder = SymbolicDecoderSystem()
    decoder.add_transition("A", "B", base_weight=1.0, metadata={"flip_depth": 1, "vowel_flow": True, "consonant_clarity": 0.5})
    decoder.add_transition("B", "C", base_weight=1.0, metadata={"flip_depth": 2, "vowel_flow": False, "consonant_clarity": 2.0})
    results = decoder.decode("A", "C", top_n=1)
    # Score: (1.0 * (1 + 1)/1 * 0.5) + (1.0 * (1 + 2)/2 * 2.0) = 1.0 + 3.0 = 4.0
    assert abs(results[0][1] - 4.0) < 0.01
